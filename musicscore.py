# -*- coding: utf-8 -*-
"""MusicScore.ipynb

Automatically generated by Colaboratory.
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd '/content/drive/MyDrive/MusicProject/'
xml_file = 'Set_2.xml'
import xml.etree.ElementTree as ET
tree = ET.parse(xml_file)
root = tree.getroot()

import math

notes = []
octaves = []
fingerings = []
num_notes_if_chord = []

num_notes_per_page = []
num_notes_minus_one_measure = []
backwards_or_forwards = []
num_backwards_or_forwards = []
page_to_repeat_from = -1

pages_backwards = []
num_to_turn_back = []

measures_per_page = []
notes_per_measures = []
time_sigs = {}

num_notes = 0
measure_notes = []
num_notes_per_measure = 0
num_measures = 0
total_pages = 0

is_chord = False
for child in root:
  if (child.tag == "part"):
    for measure in child:
      measure_info = measure.attrib
      measure_number = measure_info['number']
      num_measures = num_measures + 1
      if (measure_number != "1"):
        measure_notes.append(num_notes_per_measure)
        num_notes_per_measure = 0
      for attribute in measure:
        if (attribute.tag == "print"):
          page_num_dict = attribute.attrib
          if ('page-number' in page_num_dict.keys()):
            num_page = page_num_dict['page-number']
            if (num_page != '1'):
              num_notes_per_page.append(num_notes)
              notes_per_measures.append(measure_notes)
              measure_notes = []
              num_notes = 0
              num_measures = num_measures - 1
              measures_per_page.append(num_measures)
              total_pages = int(num_page)
        elif (attribute.tag == "repeat"):
          page_to_repeat_from = num_pages[-1]
        elif (attribute.tag == "repeat-end"):
          pages_backwards.append(page_num_dict['page-number'])
          num_to_turn_back.append(page_num_dict['page-number'] - page_to_repeat_from)
        elif (attribute.tag == "note"):
          num_notes = num_notes + 1
          is_chord = False
          num_notes_per_measure = num_notes_per_measure + 1
          for note_info in attribute:
            if (note_info.tag == "pitch"):
              for current_note in note_info:
                if (current_note.tag == "step"):
                  notes.append(current_note.text)
                elif (current_note.tag == "octave"):
                  octaves.append(current_note.text)
            elif (note_info.tag == "duration"):
              note_duration = note_info.text
            elif (note_info.tag == "trill" or note_info.tag == "tremolo"):
              num_notes = num_notes + (time_signature)*note_duration
            elif (note_info.tag == "chord"):
              is_chord = True
          num_notes_if_chord.append(is_chord)
        for element in attribute:
          if (element.tag == "time"):
            for info in element:
              if (info.tag == "beats"):
                beats = info.text
              elif (info.tag == "beat-type"):
                per = info.text
                time_signature = "{}/{}".format(beats,per)
                time_sigs[measure_number] = time_signature

fourth_col = []    
for i in range(len(num_notes_if_chord)):
  if (num_notes_if_chord[i] == False):
    last_not_chord = i
    fourth_col.append(1)
  else:
    for j in range(last_not_chord-1,i):
      fourth_col.append(i-last_not_chord + 1)
   
num_notes_per_page.append(num_notes)
notes_per_measures.append(measure_notes)

total_notes = sum(num_notes_per_page)
for pages in notes_per_measures:
  page_total = 0
  for i in range(0,len(pages)-1):
    page_total = page_total + pages[i]
  num_notes_minus_one_measure.append(page_total)

txt_first_col = []

for i in range(len(num_notes_minus_one_measure)):
  pages_notes = math.ceil(num_notes_per_page[i]*0.95)
  txt_first_col.append(max(pages_notes,num_notes_minus_one_measure[i]))

for i in range(1,total_pages+1):
  if (i in pages_backwards):
    backwards_or_forwards.append('B')
    turn_back = num_to_turn_back[i]
    num_backwards_or_forwards.append(turn_back)
    for j in range(i,turn_back):
      backwards_or_forwards.append('F')
      num_backwards_or_forwards.append(1)
  else:
    backwards_or_forwards.append('F')
    num_backwards_or_forwards.append(1)

for i in range(total_notes):
  fingerings.append(0)

def user_supplied_fingerings(note_numbers,fingers):
  for i in range(total_notes):
    if (i not in note_numbers):
      continue
    else:
      fingerings.append(fingers[i])

def user_supplied_trills(trill_note_numbers,fingers):
  for i in range(total_notes):
    if (i not in trill_note_numbers):
      continue
    else:
      num_notes_if_chord = fingers[i]

import pandas as pd

df = pd.DataFrame(list(zip(*[notes, octaves, fingerings, fourth_col])))
df.to_csv('set_2.csv', index=False)

df = pd.DataFrame(list(zip(*[txt_first_col, num_notes_per_page, backwards_or_forwards, num_backwards_or_forwards])))
df.to_csv('set_2_txt.csv', index=False)